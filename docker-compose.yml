services:
  # PostgreSQL Database Service
  database:
    image: postgres:16-alpine  # Official PostgreSQL image (alpine = lightweight)
    container_name: whoisalice_database
    env_file:
      - .env  # Load environment variables from .env file
    volumes:
      # Mount named volume to persist database data
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"  # Expose PostgreSQL port (host:container)
    restart: unless-stopped  # Auto-restart on failure, but not if manually stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - backend  # Connect to backend network

  # RabbitMQ Message Broker Service
  rabbitmq:
    image: rabbitmq:3-management-alpine  # RabbitMQ with management UI
    container_name: whoisalice_rabbitmq
    env_file:
      - .env  # RabbitMQ will use RABBITMQ_DEFAULT_USER and RABBITMQ_DEFAULT_PASS
    volumes:
      # Mount named volume to persist RabbitMQ data
      - rabbitmq_data:/var/lib/rabbitmq
    ports:
      - "5672:5672"   # AMQP protocol port
      - "15672:15672" # Management web UI (http://localhost:15672)
    restart: on-failure  # Restart only on failure
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      - backend

  # FastAPI Application Service
  app:
    build:
      context: ./app  # Build context directory
      dockerfile: Dockerfile  # Dockerfile name
    container_name: whoisalice_app
    env_file:
      - .env  # Load environment variables from root .env file
    volumes:
      # Mount source code for live reload during development
      - ./app/src:/app/src
      # Mount audio directories (shared with workers)
      - ./volumes/audio_uploads:/app/volumes/audio_uploads
      - ./volumes/audio_results:/app/volumes/audio_results
    depends_on:
      database:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    ports:
      - "127.0.0.1:8000:8000"  # Local dev only: API/docs on localhost (production: use nginx on 80/443 only)
    restart: unless-stopped
    healthcheck:
      # Check if app is healthy by calling /health endpoint
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s       # Check every 30 seconds
      timeout: 10s        # Timeout after 10 seconds
      retries: 3          # Retry 3 times before marking unhealthy
      start_period: 40s   # Grace period before starting checks
    networks:
      - backend

  # ML Worker Service (independent from app, own Dockerfile)
  worker:
    build:
      context: ./worker
      dockerfile: Dockerfile
    env_file:
      - .env
    environment:
      POSTGRES_HOST: database
      RABBITMQ_HOST: rabbitmq
    volumes:
      # Mount only shared code modules the worker needs (read-only)
      - ./app/src/core:/app/src/core:ro
      - ./app/src/db:/app/src/db:ro
      - ./app/src/queue:/app/src/queue:ro
      - ./app/src/services:/app/src/services:ro
      - ./app/src/worker.py:/app/src/worker.py:ro
      - ./app/src/__init__.py:/app/src/__init__.py:ro
      # Audio directories (shared with app service)
      - ./volumes/audio_uploads:/app/volumes/audio_uploads
      - ./volumes/audio_results:/app/volumes/audio_results
    depends_on:
      database:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - backend
    deploy:
      replicas: 2

  # Nginx Reverse Proxy Service
  web-proxy:
    image: nginx:alpine  # Official nginx image
    container_name: whoisalice_nginx
    volumes:
      # Mount custom nginx configuration
      - ./web-proxy/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app  # Start after app service
    ports:
      - "80:80"    # HTTP port
      - "443:443"  # HTTPS port
    restart: unless-stopped
    networks:
      - backend

# Named volumes - data persists even if containers are removed
volumes:
  postgres_data:   # PostgreSQL database files
  rabbitmq_data:   # RabbitMQ queue data and config

# Networks - allow containers to communicate with each other
networks:
  backend:
    driver: bridge  # Default Docker network driver
